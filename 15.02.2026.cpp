
//1. Указатель на константное целое число

cpp
const int value = 5;
const int* ptr = &value;  // указатель на const int

// Попытка изменить значение:
*ptr = 10;  // ОШИБКА: нельзя изменять const через указатель

// Изменение адреса:
int another = 7;
ptr = &another;  // ДОПУСТИМО: сам указатель не const
//2. Константный указатель на целое число

cpp
int value = 5;
int* const ptr = &value;  // const указатель на int

// Изменение значения:
*ptr = 10;  // ДОПУСТИМО: значение не const

// Изменение адреса:
int another = 7;
ptr = &another;  // ОШИБКА: указатель const, нельзя переназначить
//3. Константный указатель на константу

cpp
int value = 5;
const int* const ptr = &value;  // const указатель на const int
// Ни *ptr, ни ptr изменить нельзя
//4. Указатель с перенаправлением, но без изменения значения

cpp
int a = 10, b = 20;
const int* ptr = &a;  // можно менять ptr, но нельзя *ptr

ptr = &b;      // ДОПУСТИМО
*ptr = 30;     // ОШИБКА
//5. Анализ ошибок компиляции

Ошибку вызывает строка 9 (*p = y;):

p имеет тип const int*, значит, запись через *p запрещена.

//Остальные строки корректны.

//Часть 2. Динамическая память
//6. Динамическая переменная double

cpp
double* dptr = new double;
*dptr = 3.14;
std::cout << *dptr << std::endl;
delete dptr;
//7. Динамический массив чисел, кратных 3

cpp
int n = 5;
int* arr = new int[n];
for (int i = 0; i < n; ++i) {
    arr[i] = 3 * (i + 1);  // 3, 6, 9, 12, 15
}
//8. Поиск максимума в динамическом массиве

cpp
int max = arr[0];
for (int i = 1; i < n; ++i) {
    if (arr[i] > max) max = arr[i];
}
std::cout << "Max: " << max << std::endl;
//9. Освобождение массива

cpp
delete[] arr;  // ВАЖНО: delete[], а не delete
//10. Ошибка в коде

cpp
int* arr = new int[5];
delete arr;  // ОШИБКА!
//Причина: для массивов нужно delete[], а не delete. Иначе — утечка памяти и неопределённое поведение.

//Часть 3. Связь указателей и массивов
//11. Заполнение через арифметику указателей

cpp
int* arr = new int[5];
for (int* p = arr; p < arr + 5; ++p) {
    *p = (p - arr + 1) * 10;  // 10, 20, 30, 40, 50
}
//12. Вывод через *(arr + i)

cpp
for (int i = 0; i < 5; ++i) {
    std::cout << *(arr + i) << " ";
}
//13. Эквивалентность arr[i] и *(arr + i)

cpp
for (int i = 0; i < 5; ++i) {
    std::cout << "arr[" << i << "] = " << arr[i] 
             << ", *(arr + " << i << ") = " << *(arr + i) << std::endl;
}
// Вывод будет идентичным для обоих выражений
//Часть 4. Ссылки
//14. Ссылка и изменение значения

cpp
int x = 10;
int& ref = x;
ref = 20;  // x теперь равен 20
std::cout << x;  // 20
//15. Перенаправление ссылки

cpp
int a = 10, b = 20;
int& ref = a;
ref = b;  // НЕ перенаправление! Это присвоение значения b в a
// Ссылка всегда привязана к исходной переменной
//Вывод: ссылки нельзя переназначать после инициализации.

//16. Функция увеличения числа

//Через указатель:

cpp
void inc_ptr(int* p) {
    (*p)++;
}
//Через ссылку:

cpp
void inc_ref(int& r) {
    r++;
}
//17. const ссылка

cpp
int x = 10;
const int& cref = x;
cref = 20;  // ОШИБКА: нельзя изменять через const ссылку
///Часть 5. Функции и память
//18. Функция выделения памяти

cpp
int* create_int() {
    return new int(42);
}
//19. Использование в main()

cpp
int main() {
    int* ptr = create_int();
    std::cout << *ptr << std::endl;
    delete ptr;  // Обязательное освобождение
    return 0;
}
//20. Опасность функции f()

cpp
int& f() {
    int x = 10;
    return x;  // ОПАСНОСТЬ!
}
